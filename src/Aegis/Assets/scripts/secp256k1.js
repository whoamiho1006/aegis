!function () { function n(n, F) { return new BN(n, F) } function F(F) { return n(randomBytes(32)).umod(F) } "undefined" != typeof module ? (BN = module.require("bn.js"), randomBytes = module.require("crypto").randomBytes) : (randomBytes = (n => window.crypto.getRandomValues(new Uint8Array(n))), window.Secp256k1 = exports = {}); const t = n(0), e = n(7), r = n("79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", 16), o = n("483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", 16), u = n("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16), c = n("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16), i = n(0), s = n(1); function f(n, F) { let t = [i, i, i]; if (0 == F || 0 == n[0] && 0 == n[1]) return t; let e = [n[0], n[1], n[2]]; const r = F.clone(); for (; 0 != r;)r.testn(0) && (t = p(e, t)), e = A(e), r.iushrn(1); return t } function d(n, F, t) { return n.mul(F).umod(t) } function B(n, F, t) { return n.add(F).umod(t) } function l(n, F) { return n.invm(F) } function m(n) { return y(f(D(r, o), n)) } function y(n) { const F = l(n[2], u), t = d(F, F, u); return [d(n[0], t, u), d(n[1], d(F, t, u), u)] } function A(F) { if (0 == F[1]) return [s, s, i]; const e = d(F[2], F[2], u), r = B(d(t, d(e, e, u), u), d(n(3), d(F[0], F[0], u), u), u), o = d(F[1], F[1], u), c = d(n(4), d(F[0], o, u), u), f = B(d(r, r, u), a(d(c, n(2), u), u), u); return [f, B(d(r, B(c, a(f, u), u), u), a(d(n(8), d(o, o, u), u), u), u), d(n(2), d(F[1], F[2], u), u)] } function a(n, F) { return F.sub(n) } function p(F, t) { if (0 == t[0] && 0 == t[1] && 0 == t[2]) return F; let e = d(t[2], t[2], u); const r = d(F[0], e, u), o = d(F[1], d(e, t[2], u), u); e = d(F[2], F[2], u); let c = d(t[0], e, u), f = d(t[1], d(e, F[2], u), u); if (r.eq(c)) return o.eq(f) ? A(F) : [s, s, i]; e = d(c = B(c, a(r, u), u), c, u); const l = d(r, e, u); e = d(c, e, u), f = B(f, a(o, u), u); const m = B(B(d(f, f, u), a(e, u), u), a(d(n(2), l, u), u), u); return [m, B(d(f, B(l, a(m, u), u), u), a(d(o, e, u), u), u), d(c, d(F[2], t[2], u), u)] } function D(F, t) { return [n(F), n(t), s] } function C(n) { return ("00000000000000000000000000000000000000000000000000000000000000000000000000000000" + n.toString(16)).slice(-64) } function x(n, F) { let t = BN.red("k256"); const r = (n = n.toRed(t)).redMul(n).redMul(n).redAdd(e.toRed(t)).redSqrt(); return (r.testn(0) != F ? r.redNeg() : r).fromRed() } exports.uint256 = n, exports.ecsign = function (n, t) { for (; ;) { const e = F(u), r = m(e); if (0 == r[0]) continue; const o = d(l(e, c), B(t, d(r[0], n, c), c), c); if (0 != o && !o.testn(255)) return { r: C(r[0]), s: C(o), v: r[1].testn(0) ? 1 : 0 } } }, exports.ecrecover = function (F, t, e, i) { const s = B(n(t), u.muln(F >> 1), u); if (s.gte(u)) return null; const m = x(s, 1 == (1 & F)), A = a(n(i), c), E = l(t, c), q = d(E, e, c), g = d(E, A, c), w = D(s, m), v = y(p(f(D(r, o), g), f(w, q))); return { x: C(v[0]), y: C(v[1]) } }, exports.generatePublicKeyFromPrivateKeyData = function (n) { const F = m(n); return { x: C(F[0]), y: C(F[1]) } }, exports.decompressKey = x, exports.isValidPoint = function (n, F) { return B(d(d(n, n, u), n, u), e, u).eq(d(F, F, u)) }, exports.ecverify = function (n, F, t, e, u) { const i = l(e, c), s = d(u, i, c), B = d(t, i, c), m = D(n, F), A = y(p(f(D(r, o), s), f(m, B))); return t.eq(A[0]) } }();